// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
// <p>
// http://www.apache.org/licenses/LICENSE-2.0
// <p>
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

go_package "github.com/apache/arrow/go/arrow/flight/gen/flight"
java_package "org.apache.arrow.flight.sql.impl"
proto_package "arrow.flight.protocol.sql"

message "CommangGetSqlInfo" {
  /*
   * Values are modelled after ODBC's SQLGetInfo() function. This information is intended to provide
   * Flight SQL clients with basic, SQL syntax and SQL functions related information.
   * More information types can be added in future releases.
   * E.g. more SQL syntax support types, scalar functions support, type conversion support etc.
   *
   * Note that the set of metadata may expand.
   *
   * Initially, Flight SQL will support the following information types:
   * - Server Information - Range [0-500)
   * - Syntax Information - Range [500-1000)
   * Range [0-10,000) is reserved for defaults (see SqlInfo enum for default options).
   * Custom options should start at 10,000.
   *
   * If omitted, then all metadata will be retrieved.
   * Flight SQL Servers may choose to include additional metadata above and beyond the specified set, however they must
   * at least return the specified set. IDs ranging from 0 to 10,000 (exclusive) are reserved for future use.
   * If additional metadata is included, the metadata IDs should start from 10,000.
   */
  field repeated=true "info" "uint32" 1
}

// There will be one row per requested piece of metadata information.
schema "SqlInfoSchema" {
  field not_null=true "info_name" "uint32"
  field "value" "dense_union" {
    field "string_value" "utf8"
    field "bool_value" "bool"
    field "bigint_value" "int64"
    field "int32_bitmask" "int32"
    field "string_list" "list" {
      // default field name "item" is not used here
      field "string_data" "utf8"
    }
    field "int32_to_int32_list_map" "map" {
      key "int32"
      value "list" {
        // item is used, so no need to specify the field name
        item "int32"
      }
    }
  }
}

// Options for CommandGetSqlInfo.
enum "SqlInfo" {

  // Server Information [0-500): Provides basic information about the Flight SQL Server.

  // Retrieves a UTF-8 sti with the name of the Flight SQL Server.
  FLIGHT_SQL_SERVER_NAME 0

  // Retrieves a UTF-8 stringwih the native version of the Flight SQL Server.
  FLIGHT_SQL_SERVER_VERSION 1

  // Retrieves a UTF-8 string with the Arrow format version of the Flight SQL Server.
  FLIGHT_SQL_SERVER_ARROW_VERSION 2

  /*
   * Retrieves a boolean value indicating whether the Flight SQL Server is read only.
   *
   * Returns:
   * - false: if read-write
   * - true: if read only
   */
  FLIGHT_SQL_SERVER_READ_ONLY 3

  /*
   * Retrieves a boolean value indicating whether the Flight SQL Server supports executing
   * SQL queries.
   *
   * Note that the absence of this info (as opposed to a false value) does not necessarily
   * mean that SQL is not supported, as this property was not originally defined.
   */
  FLIGHT_SQL_SERVER_SQL 4

  /*
   * Retrieves a boolean value indicating whether the Flight SQL Server supports executing
   * Substrait plans.
   */
  FLIGHT_SQL_SERVER_SUBSTRAIT 5

  /*
   * Retrieves a string value indicating the minimum supported Substrait version, or null
   * if Substrait is not supported.
   */
  FLIGHT_SQL_SERVER_SUBSTRAIT_MIN_VERSION 6

  /*
   * Retrieves a string value indicating the maximum supported Substrait version, or null
   * if Substrait is not supported.
   */
  FLIGHT_SQL_SERVER_SUBSTRAIT_MAX_VERSION 7

  /*
   * Retrieves an int32 indicating whether the Flight SQL Server supports the
   * BeginTransaction/EndTransaction/BeginSavepoint/EndSavepoint actions.
   *
   * Even if this is not supported, the database may still support explicit "BEGIN
   * TRANSACTION"/"COMMIT" SQL statements (see SQL_TRANSACTIONS_SUPPORTED); this property
   * is only about whether the server implements the Flight SQL API endpoints.
   *
   * The possible values are listed in `SqlSupportedTransaction`.
   */
  FLIGHT_SQL_SERVER_TRANSACTION 8

  /*
   * Retrieves a boolean value indicating whether the Flight SQL Server supports explicit
   * query cancellation (the CancelQuery action).
   */
  FLIGHT_SQL_SERVER_CANCEL 9

  /*
   * Retrieves a boolean value indicating whether the Flight SQL Server supports executing
   * bulk ingestion.
   */
   FLIGHT_SQL_SERVER_BULK_INGESTION 10

  /*
   * Retrieves a boolean value indicating whether transactions are supported for bulk ingestion. If not, invoking
   * the method commit in the context of a bulk ingestion is a noop, and the isolation level is
   * `arrow.flight.protocol.sql.SqlTransactionIsolationLevel.TRANSACTION_NONE`.
   *
   * Returns:
   * - false: if bulk ingestion transactions are unsupported;
   * - true: if bulk ingestion transactions are supported.
   */
   FLIGHT_SQL_SERVER_INGEST_TRANSACTIONS_SUPPORTED 11

  /*
   * Retrieves an int32 indicating the timeout (in milliseconds) for prepared statement handles.
   *
   * If 0, there is no timeout.  Servers should reset the timeout when the handle is used in a command.
   */
  FLIGHT_SQL_SERVER_STATEMENT_TIMEOUT 100

  /*
   * Retrieves an int32 indicating the timeout (in milliseconds) for transactions, since transactions are not tied to a connection.
   *
   * If 0, there is no timeout.  Servers should reset the timeout when the handle is used in a command.
   */
  FLIGHT_SQL_SERVER_TRANSACTION_TIMEOUT 101

  // SQL Syntax Information [500-1000): provides information about SQL syntax supported by the Flight SQL Server.

  /*
   * Retrieves a boolean value indicating whether the Flight SQL Server supports CREATE and DROP of catalogs.
   *
   * Returns:
   * - false: if it doesn't support CREATE and DROP of catalogs.
   * - true: if it supports CREATE and DROP of catalogs.
   */
  SQL_DDL_CATALOG 500

  /*
   * Retrieves a boolean value indicating whether the Flight SQL Server supports CREATE and DROP of schemas.
   *
   * Returns:
   * - false: if it doesn't support CREATE and DROP of schemas.
   * - true: if it supports CREATE and DROP of schemas.
   */
  SQL_DDL_SCHEMA 501

  /*
   * Indicates whether the Flight SQL Server supports CREATE and DROP of tables.
   *
   * Returns:
   * - false: if it doesn't support CREATE and DROP of tables.
   * - true: if it supports CREATE and DROP of tables.
   */
  SQL_DDL_TABLE 502

  /*
   * Retrieves a int32 ordinal representing the case sensitivity of catalog, table, schema and table names.
   *
   * The possible values are listed in `arrow.flight.protocol.sql.SqlSupportedCaseSensitivity`.
   */
  SQL_IDENTIFIER_CASE 503

  // Retrieves a UTF-8 string with the supported character(s) used to surround a delimited identifier.
  SQL_IDENTIFIER_QUOTE_CHAR 504

  /*
   * Retrieves a int32 describing the case sensitivity of quoted identifiers.
   *
   * The possible values are listed in `arrow.flight.protocol.sql.SqlSupportedCaseSensitivity`.
   */
  SQL_QUOTED_IDENTIFIER_CASE 505

  /*
   * Retrieves a boolean value indicating whether all tables are selectable.
   *
   * Returns:
   * - false: if not all tables are selectable or if none are;
   * - true: if all tables are selectable.
   */
  SQL_ALL_TABLES_ARE_SELECTABLE 506

  /*
   * Retrieves the null ordering.
   *
   * Returns a int32 ordinal for the null ordering being used, as described in
   * `arrow.flight.protocol.sql.SqlNullOrdering`.
   */
  SQL_NULL_ORDERING 507

  // Retrieves a UTF-8 string list with values of the supported keywords.
  SQL_KEYWORDS 508

  // Retrieves a UTF-8 string list with values of the supported numeric functions.
  SQL_NUMERIC_FUNCTIONS 509

  // Retrieves a UTF-8 string list with values of the supported string functions.
  SQL_STRING_FUNCTIONS 510

  // Retrieves a UTF-8 string list with values of the supported system functions.
  SQL_SYSTEM_FUNCTIONS 511

  // Retrieves a UTF-8 string list with values of the supported datetime functions.
  SQL_DATETIME_FUNCTIONS 512

  /*
   * Retrieves the UTF-8 string that can be used to escape wildcard characters.
   * This is the string that can be used to escape '_' or '%' in the catalog search parameters that are a pattern
   * (and therefore use one of the wildcard characters).
   * The '_' character represents any single character; the '%' character represents any sequence of zero or more
   * characters.
   */
  SQL_SEARCH_STRING_ESCAPE 513

  /*
   * Retrieves a UTF-8 string with all the "extra" characters that can be used in unquoted identifier names
   * (those beyond a-z, A-Z, 0-9 and _).
   */
  SQL_EXTRA_NAME_CHARACTERS 514

  /*
   * Retrieves a boolean value indicating whether column aliasing is supported.
   * If so, the SQL AS clause can be used to provide names for computed columns or to provide alias names for columns
   * as required.
   *
   * Returns:
   * - false: if column aliasing is unsupported;
   * - true: if column aliasing is supported.
   */
  SQL_SUPPORTS_COLUMN_ALIASING 515

  /*
   * Retrieves a boolean value indicating whether concatenations between null and non-null values being
   * null are supported.
   *
   * - Returns:
   * - false: if concatenations between null and non-null values being null are unsupported;
   * - true: if concatenations between null and non-null values being null are supported.
   */
  SQL_NULL_PLUS_NULL_IS_NULL 516

  /*
   * Retrieves a map where the key is the type to convert from and the value is a list with the types to convert to,
   * indicating the supported conversions. Each key and each item on the list value is a value to a predefined type on
   * SqlSupportsConvert enum.
   * The returned map will be:  map<int32, list<int32>>
   */
  SQL_SUPPORTS_CONVERT 517

  /*
   * Retrieves a boolean value indicating whether, when table correlation names are supported,
   * they are restricted to being different from the names of the tables.
   *
   * Returns:
   * - false: if table correlation names are unsupported;
   * - true: if table correlation names are supported.
   */
  SQL_SUPPORTS_TABLE_CORRELATION_NAMES 518

  /*
   * Retrieves a boolean value indicating whether, when table correlation names are supported,
   * they are restricted to being different from the names of the tables.
   *
   * Returns:
   * - false: if different table correlation names are unsupported;
   * - true: if different table correlation names are supported
   */
  SQL_SUPPORTS_DIFFERENT_TABLE_CORRELATION_NAMES 519

  /*
   * Retrieves a boolean value indicating whether expressions in ORDER BY lists are supported.
   *
   * Returns:
   * - false: if expressions in ORDER BY are unsupported;
   * - true: if expressions in ORDER BY are supported;
   */
  SQL_SUPPORTS_EXPRESSIONS_IN_ORDER_BY 520

  /*
   * Retrieves a boolean value indicating whether using a column that is not in the SELECT statement in a GROUP BY
   * clause is supported.
   *
   * Returns:
   * - false: if using a column that is not in the SELECT statement in a GROUP BY clause is unsupported;
   * - true: if using a column that is not in the SELECT statement in a GROUP BY clause is supported.
   */
  SQL_SUPPORTS_ORDER_BY_UNRELATED 521

  /*
   * Retrieves the supported GROUP BY commands;
   *
   * Returns an int32 bitmask value representing the supported commands.
   * The returned bitmask should be parsed in order to retrieve the supported commands.
   *
   * For instance:
   * - return 0 (\b0)   => [] (GROUP BY is unsupported);
   * - return 1 (\b1)   => [SQL_GROUP_BY_UNRELATED];
   * - return 2 (\b10)  => [SQL_GROUP_BY_BEYOND_SELECT];
   * - return 3 (\b11)  => [SQL_GROUP_BY_UNRELATED, SQL_GROUP_BY_BEYOND_SELECT].
   * Valid GROUP BY types are described under `arrow.flight.protocol.sql.SqlSupportedGroupBy`.
   */
  SQL_SUPPORTED_GROUP_BY 522

  /*
   * Retrieves a boolean value indicating whether specifying a LIKE escape clause is supported.
   *
   * Returns:
   * - false: if specifying a LIKE escape clause is unsupported;
   * - true: if specifying a LIKE escape clause is supported.
   */
  SQL_SUPPORTS_LIKE_ESCAPE_CLAUSE 523

  /*
   * Retrieves a boolean value indicating whether columns may be defined as non-nullable.
   *
   * Returns:
   * - false: if columns cannot be defined as non-nullable;
   * - true: if columns may be defined as non-nullable.
   */
  SQL_SUPPORTS_NON_NULLABLE_COLUMNS 524

  /*
   * Retrieves the supported SQL grammar level as per the ODBC specification.
   *
   * Returns an int32 bitmask value representing the supported SQL grammar level.
   * The returned bitmask should be parsed in order to retrieve the supported grammar levels.
   *
   * For instance:
   * - return 0 (\b0)   => [] (SQL grammar is unsupported);
   * - return 1 (\b1)   => [SQL_MINIMUM_GRAMMAR];
   * - return 2 (\b10)  => [SQL_CORE_GRAMMAR];
   * - return 3 (\b11)  => [SQL_MINIMUM_GRAMMAR, SQL_CORE_GRAMMAR];
   * - return 4 (\b100) => [SQL_EXTENDED_GRAMMAR];
   * - return 5 (\b101) => [SQL_MINIMUM_GRAMMAR, SQL_EXTENDED_GRAMMAR];
   * - return 6 (\b110) => [SQL_CORE_GRAMMAR, SQL_EXTENDED_GRAMMAR];
   * - return 7 (\b111) => [SQL_MINIMUM_GRAMMAR, SQL_CORE_GRAMMAR, SQL_EXTENDED_GRAMMAR].
   * Valid SQL grammar levels are described under `arrow.flight.protocol.sql.SupportedSqlGrammar`.
   */
  SQL_SUPPORTED_GRAMMAR 525

  /*
   * Retrieves the supported ANSI92 SQL grammar level.
   *
   * Returns an int32 bitmask value representing the supported ANSI92 SQL grammar level.
   * The returned bitmask should be parsed in order to retrieve the supported commands.
   *
   * For instance:
   * - return 0 (\b0)   => [] (ANSI92 SQL grammar is unsupported);
   * - return 1 (\b1)   => [ANSI92_ENTRY_SQL];
   * - return 2 (\b10)  => [ANSI92_INTERMEDIATE_SQL];
   * - return 3 (\b11)  => [ANSI92_ENTRY_SQL, ANSI92_INTERMEDIATE_SQL];
   * - return 4 (\b100) => [ANSI92_FULL_SQL];
   * - return 5 (\b101) => [ANSI92_ENTRY_SQL, ANSI92_FULL_SQL];
   * - return 6 (\b110) => [ANSI92_INTERMEDIATE_SQL, ANSI92_FULL_SQL];
   * - return 7 (\b111) => [ANSI92_ENTRY_SQL, ANSI92_INTERMEDIATE_SQL, ANSI92_FULL_SQL].
   * Valid ANSI92 SQL grammar levels are described under `arrow.flight.protocol.sql.SupportedAnsi92SqlGrammarLevel`.
   */
  SQL_ANSI92_SUPPORTED_LEVEL 526

  /*
   * Retrieves a boolean value indicating whether the SQL Integrity Enhancement Facility is supported.
   *
   * Returns:
   * - false: if the SQL Integrity Enhancement Facility is supported;
   * - true: if the SQL Integrity Enhancement Facility is supported.
   */
  SQL_SUPPORTS_INTEGRITY_ENHANCEMENT_FACILITY 527

  /*
   * Retrieves the support level for SQL OUTER JOINs.
   *
   * Returns a int32 ordinal for the SQL ordering being used, as described in
   * `arrow.flight.protocol.sql.SqlOuterJoinsSupportLevel`.
   */
  SQL_OUTER_JOINS_SUPPORT_LEVEL 528

  // Retrieves a UTF-8 string with the preferred term for "schema".
  SQL_SCHEMA_TERM 529

  // Retrieves a UTF-8 string with the preferred term for "procedure".
  SQL_PROCEDURE_TERM 530

  /*
   * Retrieves a UTF-8 string with the preferred term for "catalog".
   * If a empty string is returned its assumed that the server does NOT supports catalogs.
   */
  SQL_CATALOG_TERM 531

  /*
   * Retrieves a boolean value indicating whether a catalog appears at the start of a fully qualified table name.
   *
   * - false: if a catalog does not appear at the start of a fully qualified table name;
   * - true: if a catalog appears at the start of a fully qualified table name.
   */
  SQL_CATALOG_AT_START 532

  /*
   * Retrieves the supported actions for a SQL schema.
   *
   * Returns an int32 bitmask value representing the supported actions for a SQL schema.
   * The returned bitmask should be parsed in order to retrieve the supported actions for a SQL schema.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no supported actions for SQL schema);
   * - return 1 (\b1)   => [SQL_ELEMENT_IN_PROCEDURE_CALLS];
   * - return 2 (\b10)  => [SQL_ELEMENT_IN_INDEX_DEFINITIONS];
   * - return 3 (\b11)  => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS];
   * - return 4 (\b100) => [SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
   * - return 5 (\b101) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
   * - return 6 (\b110) => [SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
   * - return 7 (\b111) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS].
   * Valid actions for a SQL schema described under `arrow.flight.protocol.sql.SqlSupportedElementActions`.
   */
  SQL_SCHEMAS_SUPPORTED_ACTIONS 533

  /*
   * Retrieves the supported actions for a SQL schema.
   *
   * Returns an int32 bitmask value representing the supported actions for a SQL catalog.
   * The returned bitmask should be parsed in order to retrieve the supported actions for a SQL catalog.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no supported actions for SQL catalog);
   * - return 1 (\b1)   => [SQL_ELEMENT_IN_PROCEDURE_CALLS];
   * - return 2 (\b10)  => [SQL_ELEMENT_IN_INDEX_DEFINITIONS];
   * - return 3 (\b11)  => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS];
   * - return 4 (\b100) => [SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
   * - return 5 (\b101) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
   * - return 6 (\b110) => [SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
   * - return 7 (\b111) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS].
   * Valid actions for a SQL catalog are described under `arrow.flight.protocol.sql.SqlSupportedElementActions`.
   */
  SQL_CATALOGS_SUPPORTED_ACTIONS 534

  /*
   * Retrieves the supported SQL positioned commands.
   *
   * Returns an int32 bitmask value representing the supported SQL positioned commands.
   * The returned bitmask should be parsed in order to retrieve the supported SQL positioned commands.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no supported SQL positioned commands);
   * - return 1 (\b1)   => [SQL_POSITIONED_DELETE];
   * - return 2 (\b10)  => [SQL_POSITIONED_UPDATE];
   * - return 3 (\b11)  => [SQL_POSITIONED_DELETE, SQL_POSITIONED_UPDATE].
   * Valid SQL positioned commands are described under `arrow.flight.protocol.sql.SqlSupportedPositionedCommands`.
   */
  SQL_SUPPORTED_POSITIONED_COMMANDS 535

  /*
   * Retrieves a boolean value indicating whether SELECT FOR UPDATE statements are supported.
   *
   * Returns:
   * - false: if SELECT FOR UPDATE statements are unsupported;
   * - true: if SELECT FOR UPDATE statements are supported.
   */
  SQL_SELECT_FOR_UPDATE_SUPPORTED 536

  /*
   * Retrieves a boolean value indicating whether stored procedure calls that use the stored procedure escape syntax
   * are supported.
   *
   * Returns:
   * - false: if stored procedure calls that use the stored procedure escape syntax are unsupported;
   * - true: if stored procedure calls that use the stored procedure escape syntax are supported.
   */
  SQL_STORED_PROCEDURES_SUPPORTED 537

  /*
   * Retrieves the supported SQL subqueries.
   *
   * Returns an int32 bitmask value representing the supported SQL subqueries.
   * The returned bitmask should be parsed in order to retrieve the supported SQL subqueries.
   *
   * For instance:
   * - return 0   (\b0)     => [] (no supported SQL subqueries);
   * - return 1   (\b1)     => [SQL_SUBQUERIES_IN_COMPARISONS];
   * - return 2   (\b10)    => [SQL_SUBQUERIES_IN_EXISTS];
   * - return 3   (\b11)    => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS];
   * - return 4   (\b100)   => [SQL_SUBQUERIES_IN_INS];
   * - return 5   (\b101)   => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_INS];
   * - return 6   (\b110)   => [SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_EXISTS];
   * - return 7   (\b111)   => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_INS];
   * - return 8   (\b1000)  => [SQL_SUBQUERIES_IN_QUANTIFIEDS];
   * - return 9   (\b1001)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
   * - return 10  (\b1010)  => [SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
   * - return 11  (\b1011)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
   * - return 12  (\b1100)  => [SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
   * - return 13  (\b1101)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
   * - return 14  (\b1110)  => [SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
   * - return 15  (\b1111)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
   * - ...
   * Valid SQL subqueries are described under `arrow.flight.protocol.sql.SqlSupportedSubqueries`.
   */
  SQL_SUPPORTED_SUBQUERIES 538

  /*
   * Retrieves a boolean value indicating whether correlated subqueries are supported.
   *
   * Returns:
   * - false: if correlated subqueries are unsupported;
   * - true: if correlated subqueries are supported.
   */
  SQL_CORRELATED_SUBQUERIES_SUPPORTED 539

  /*
   * Retrieves the supported SQL UNIONs.
   *
   * Returns an int32 bitmask value representing the supported SQL UNIONs.
   * The returned bitmask should be parsed in order to retrieve the supported SQL UNIONs.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no supported SQL positioned commands);
   * - return 1 (\b1)   => [SQL_UNION];
   * - return 2 (\b10)  => [SQL_UNION_ALL];
   * - return 3 (\b11)  => [SQL_UNION, SQL_UNION_ALL].
   * Valid SQL positioned commands are described under `arrow.flight.protocol.sql.SqlSupportedUnions`.
   */
  SQL_SUPPORTED_UNIONS 540

  // Retrieves a int64 value representing the maximum number of hex characters allowed in an inline binary literal.
  SQL_MAX_BINARY_LITERAL_LENGTH 541

  // Retrieves a int64 value representing the maximum number of characters allowed for a character literal.
  SQL_MAX_CHAR_LITERAL_LENGTH 542

  // Retrieves a int64 value representing the maximum number of characters allowed for a column name.
  SQL_MAX_COLUMN_NAME_LENGTH 543

  // Retrieves a int64 value representing the maximum number of columns allowed in a GROUP BY clause.
  SQL_MAX_COLUMNS_IN_GROUP_BY 544

  // Retrieves a int64 value representing the maximum number of columns allowed in an index.
  SQL_MAX_COLUMNS_IN_INDEX 545

  // Retrieves a int64 value representing the maximum number of columns allowed in an ORDER BY clause.
  SQL_MAX_COLUMNS_IN_ORDER_BY 546

  // Retrieves a int64 value representing the maximum number of columns allowed in a SELECT list.
  SQL_MAX_COLUMNS_IN_SELECT 547

  // Retrieves a int64 value representing the maximum number of columns allowed in a table.
  SQL_MAX_COLUMNS_IN_TABLE 548

  // Retrieves a int64 value representing the maximum number of concurrent connections possible.
  SQL_MAX_CONNECTIONS 549

  // Retrieves a int64 value the maximum number of characters allowed in a cursor name.
  SQL_MAX_CURSOR_NAME_LENGTH 550

  /*
   * Retrieves a int64 value representing the maximum number of bytes allowed for an index,
   * including all of the parts of the index.
   */
  SQL_MAX_INDEX_LENGTH 551

  // Retrieves a int64 value representing the maximum number of characters allowed in a schema name.
  SQL_DB_SCHEMA_NAME_LENGTH 552

  // Retrieves a int64 value representing the maximum number of characters allowed in a procedure name.
  SQL_MAX_PROCEDURE_NAME_LENGTH 553

  // Retrieves a int64 value representing the maximum number of characters allowed in a catalog name.
  SQL_MAX_CATALOG_NAME_LENGTH 554

  // Retrieves a int64 value representing the maximum number of bytes allowed in a single row.
  SQL_MAX_ROW_SIZE 555

  /*
   * Retrieves a boolean indicating whether the return value for the JDBC method getMaxRowSize includes the SQL
   * data types LONGVARCHAR and LONGVARBINARY.
   *
   * Returns:
   * - false: if return value for the JDBC method getMaxRowSize does
   *          not include the SQL data types LONGVARCHAR and LONGVARBINARY;
   * - true: if return value for the JDBC method getMaxRowSize includes
   *         the SQL data types LONGVARCHAR and LONGVARBINARY.
   */
  SQL_MAX_ROW_SIZE_INCLUDES_BLOBS 556

  /*
   * Retrieves a int64 value representing the maximum number of characters allowed for an SQL statement;
   * a result of 0 (zero) means that there is no limit or the limit is not known.
   */
  SQL_MAX_STATEMENT_LENGTH 557

  // Retrieves a int64 value representing the maximum number of active statements that can be open at the same time.
  SQL_MAX_STATEMENTS 558

  // Retrieves a int64 value representing the maximum number of characters allowed in a table name.
  SQL_MAX_TABLE_NAME_LENGTH 559

  // Retrieves a int64 value representing the maximum number of tables allowed in a SELECT statement.
  SQL_MAX_TABLES_IN_SELECT 560

  // Retrieves a int64 value representing the maximum number of characters allowed in a user name.
  SQL_MAX_USERNAME_LENGTH 561

  /*
   * Retrieves this database's default transaction isolation level as described in
   * `arrow.flight.protocol.sql.SqlTransactionIsolationLevel`.
   *
   * Returns a int32 ordinal for the SQL transaction isolation level.
   */
  SQL_DEFAULT_TRANSACTION_ISOLATION 562

  /*
   * Retrieves a boolean value indicating whether transactions are supported. If not, invoking the method commit is a
   * noop, and the isolation level is `arrow.flight.protocol.sql.SqlTransactionIsolationLevel.TRANSACTION_NONE`.
   *
   * Returns:
   * - false: if transactions are unsupported;
   * - true: if transactions are supported.
   */
  SQL_TRANSACTIONS_SUPPORTED 563

  /*
   * Retrieves the supported transactions isolation levels.
   *
   * Returns an int32 bitmask value representing the supported transactions isolation levels.
   * The returned bitmask should be parsed in order to retrieve the supported transactions isolation levels.
   *
   * For instance:
   * - return 0   (\b0)     => [] (no supported SQL transactions isolation levels);
   * - return 1   (\b1)     => [SQL_TRANSACTION_NONE];
   * - return 2   (\b10)    => [SQL_TRANSACTION_READ_UNCOMMITTED];
   * - return 3   (\b11)    => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED];
   * - return 4   (\b100)   => [SQL_TRANSACTION_REPEATABLE_READ];
   * - return 5   (\b101)   => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 6   (\b110)   => [SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 7   (\b111)   => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 8   (\b1000)  => [SQL_TRANSACTION_REPEATABLE_READ];
   * - return 9   (\b1001)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 10  (\b1010)  => [SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 11  (\b1011)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 12  (\b1100)  => [SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 13  (\b1101)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 14  (\b1110)  => [SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 15  (\b1111)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 16  (\b10000) => [SQL_TRANSACTION_SERIALIZABLE];
   * - ...
   * Valid SQL positioned commands are described under `arrow.flight.protocol.sql.SqlTransactionIsolationLevel`.
   */
  SQL_SUPPORTED_TRANSACTIONS_ISOLATION_LEVELS 564

  /*
   * Retrieves a boolean value indicating whether a data definition statement within a transaction forces
   * the transaction to commit.
   *
   * Returns:
   * - false: if a data definition statement within a transaction does not force the transaction to commit;
   * - true: if a data definition statement within a transaction forces the transaction to commit.
   */
  SQL_DATA_DEFINITION_CAUSES_TRANSACTION_COMMIT 565

  /*
   * Retrieves a boolean value indicating whether a data definition statement within a transaction is ignored.
   *
   * Returns:
   * - false: if a data definition statement within a transaction is taken into account;
   * - true: a data definition statement within a transaction is ignored.
   */
  SQL_DATA_DEFINITIONS_IN_TRANSACTIONS_IGNORED 566

  /*
   * Retrieves an int32 bitmask value representing the supported result set types.
   * The returned bitmask should be parsed in order to retrieve the supported result set types.
   *
   * For instance:
   * - return 0   (\b0)     => [] (no supported result set types);
   * - return 1   (\b1)     => [SQL_RESULT_SET_TYPE_UNSPECIFIED];
   * - return 2   (\b10)    => [SQL_RESULT_SET_TYPE_FORWARD_ONLY];
   * - return 3   (\b11)    => [SQL_RESULT_SET_TYPE_UNSPECIFIED, SQL_RESULT_SET_TYPE_FORWARD_ONLY];
   * - return 4   (\b100)   => [SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
   * - return 5   (\b101)   => [SQL_RESULT_SET_TYPE_UNSPECIFIED, SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
   * - return 6   (\b110)   => [SQL_RESULT_SET_TYPE_FORWARD_ONLY, SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
   * - return 7   (\b111)   => [SQL_RESULT_SET_TYPE_UNSPECIFIED, SQL_RESULT_SET_TYPE_FORWARD_ONLY, SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
   * - return 8   (\b1000)  => [SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE];
   * - ...
   * Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetType`.
   */
  SQL_SUPPORTED_RESULT_SET_TYPES 567

  /*
   * Returns an int32 bitmask value concurrency types supported for
   * `arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_UNSPECIFIED`.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no supported concurrency types for this result set type)
   * - return 1 (\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
   * - return 2 (\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
   * - return 3 (\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
   * - return 4 (\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 5 (\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 6 (\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 7 (\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
   */
  SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_UNSPECIFIED 568

  /*
   * Returns an int32 bitmask value concurrency types supported for
   * `arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_FORWARD_ONLY`.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no supported concurrency types for this result set type)
   * - return 1 (\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
   * - return 2 (\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
   * - return 3 (\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
   * - return 4 (\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 5 (\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 6 (\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 7 (\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
   */
  SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_FORWARD_ONLY 569

  /*
   * Returns an int32 bitmask value concurrency types supported for
   * `arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE`.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no supported concurrency types for this result set type)
   * - return 1 (\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
   * - return 2 (\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
   * - return 3 (\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
   * - return 4 (\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 5 (\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 6 (\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 7 (\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
   */
  SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_SENSITIVE 570

  /*
   * Returns an int32 bitmask value concurrency types supported for
   * `arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE`.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no supported concurrency types for this result set type)
   * - return 1 (\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
   * - return 2 (\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
   * - return 3 (\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
   * - return 4 (\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 5 (\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 6 (\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 7 (\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
   */
  SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_INSENSITIVE 571

  /*
   * Retrieves a boolean value indicating whether this database supports batch updates.
   *
   * - false: if this database does not support batch updates;
   * - true: if this database supports batch updates.
   */
  SQL_BATCH_UPDATES_SUPPORTED 572

  /*
   * Retrieves a boolean value indicating whether this database supports savepoints.
   *
   * Returns:
   * - false: if this database does not support savepoints;
   * - true: if this database supports savepoints.
   */
  SQL_SAVEPOINTS_SUPPORTED 573

  /*
   * Retrieves a boolean value indicating whether named parameters are supported in callable statements.
   *
   * Returns:
   * - false: if named parameters in callable statements are unsupported;
   * - true: if named parameters in callable statements are supported.
   */
  SQL_NAMED_PARAMETERS_SUPPORTED 574

  /*
   * Retrieves a boolean value indicating whether updates made to a LOB are made on a copy or directly to the LOB.
   *
   * Returns:
   * - false: if updates made to a LOB are made directly to the LOB;
   * - true: if updates made to a LOB are made on a copy.
   */
  SQL_LOCATORS_UPDATE_COPY 575

  /*
   * Retrieves a boolean value indicating whether invoking user-defined or vendor functions
   * using the stored procedure escape syntax is supported.
   *
   * Returns:
   * - false: if invoking user-defined or vendor functions using the stored procedure escape syntax is unsupported;
   * - true: if invoking user-defined or vendor functions using the stored procedure escape syntax is supported.
   */
  SQL_STORED_FUNCTIONS_USING_CALL_SYNTAX_SUPPORTED 576
}

// The level of support for Flight SQL transaction RPCs.
enum "SqlSupportedTransaction" {
  // Unknown/not indicated/no support
  SQL_SUPPORTED_TRANSACTION_NONE 0
  // Transactions, but not savepoints.
  // A savepoint is a mark within a transaction that can be individually
  // rolled back to. Not all databases support savepoints.
  SQL_SUPPORTED_TRANSACTION_TRANSACTION 1
  // Transactions and savepoints
  SQL_SUPPORTED_TRANSACTION_SAVEPOINT 2
}

enum "SqlSupportedCaseSensitivity" {
  SQL_CASE_SENSITIVITY_UNKNOWN 0
  SQL_CASE_SENSITIVITY_CASE_INSENSITIVE 1
  SQL_CASE_SENSITIVITY_UPPERCASE 2
  SQL_CASE_SENSITIVITY_LOWERCASE 3
}

enum "SqlNullOrdering" {
  SQL_NULLS_SORTED_HIGH 0
  SQL_NULLS_SORTED_LOW 1
  SQL_NULLS_SORTED_AT_START 2
  SQL_NULLS_SORTED_AT_END 3
}

enum "SupportedSqlGrammar" {
  SQL_MINIMUM_GRAMMAR 0
  SQL_CORE_GRAMMAR 1
  SQL_EXTENDED_GRAMMAR 2
}

enum "SupportedAnsi92SqlGrammarLevel" {
  ANSI92_ENTRY_SQL 0
  ANSI92_INTERMEDIATE_SQL 1
  ANSI92_FULL_SQL 2
}

enum "SqlOuterJoinsSupportLevel" {
  SQL_JOINS_UNSUPPORTED 0
  SQL_LIMITED_OUTER_JOINS 1
  SQL_FULL_OUTER_JOINS 2
}

enum "SqlSupportedGroupBy" {
  SQL_GROUP_BY_UNRELATED 0
  SQL_GROUP_BY_BEYOND_SELECT 1
}

enum "SqlSupportedElementActions" {
  SQL_ELEMENT_IN_PROCEDURE_CALLS 0
  SQL_ELEMENT_IN_INDEX_DEFINITIONS 1
  SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS 2
}

enum "SqlSupportedPositionedCommands" {
  SQL_POSITIONED_DELETE 0
  SQL_POSITIONED_UPDATE 1
}

enum "SqlSupportedSubqueries" {
  SQL_SUBQUERIES_IN_COMPARISONS 0
  SQL_SUBQUERIES_IN_EXISTS 1
  SQL_SUBQUERIES_IN_INS 2
  SQL_SUBQUERIES_IN_QUANTIFIEDS 3
}

enum "SqlSupportedUnions" {
  SQL_UNION 0
  SQL_UNION_ALL 1
}

enum "SqlTransactionIsolationLevel" {
  SQL_TRANSACTION_NONE 0
  SQL_TRANSACTION_READ_UNCOMMITTED 1
  SQL_TRANSACTION_READ_COMMITTED 2
  SQL_TRANSACTION_REPEATABLE_READ 3
  SQL_TRANSACTION_SERIALIZABLE 4
}

enum "SqlSupportedTransactions" {
  SQL_TRANSACTION_UNSPECIFIED 0
  SQL_DATA_DEFINITION_TRANSACTIONS 1
  SQL_DATA_MANIPULATION_TRANSACTIONS 2
}

enum "SqlSupportedResultSetType" {
  SQL_RESULT_SET_TYPE_UNSPECIFIED 0
  SQL_RESULT_SET_TYPE_FORWARD_ONLY 1
  SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE 2
  SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE 3
}

enum "SqlSupportedResultSetConcurrency" {
  SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED 0
  SQL_RESULT_SET_CONCURRENCY_READ_ONLY 1
  SQL_RESULT_SET_CONCURRENCY_UPDATABLE 2
}

enum "SqlSupportsConvert" {
  SQL_CONVERT_BIGINT 0
  SQL_CONVERT_BINARY 1
  SQL_CONVERT_BIT 2
  SQL_CONVERT_CHAR 3
  SQL_CONVERT_DATE 4
  SQL_CONVERT_DECIMAL 5
  SQL_CONVERT_FLOAT 6
  SQL_CONVERT_INTEGER 7
  SQL_CONVERT_INTERVAL_DAY_TIME 8
  SQL_CONVERT_INTERVAL_YEAR_MONTH 9
  SQL_CONVERT_LONGVARBINARY 10
  SQL_CONVERT_LONGVARCHAR 11
  SQL_CONVERT_NUMERIC 12
  SQL_CONVERT_REAL 13
  SQL_CONVERT_SMALLINT 14
  SQL_CONVERT_TIME 15
  SQL_CONVERT_TIMESTAMP 16
  SQL_CONVERT_TINYINT 17
  SQL_CONVERT_VARBINARY 18
  SQL_CONVERT_VARCHAR 19
}

/**
 * The JDBC/ODBC-defined type of any object.
 * All the values here are the same as in the JDBC and ODBC specs.
 */
enum "XdbcDataType" {
  XDBC_UNKNOWN_TYPE 0
  XDBC_CHAR 1
  XDBC_NUMERIC 2
  XDBC_DECIMAL 3
  XDBC_INTEGER 4
  XDBC_SMALLINT 5
  XDBC_FLOAT 6
  XDBC_REAL 7
  XDBC_DOUBLE 8
  XDBC_DATETIME 9
  XDBC_INTERVAL 10
  XDBC_VARCHAR 12
  XDBC_DATE 91
  XDBC_TIME 92
  XDBC_TIMESTAMP 93
  XDBC_LONGVARCHAR -1
  XDBC_BINARY -2
  XDBC_VARBINARY -3
  XDBC_LONGVARBINARY -4
  XDBC_BIGINT -5
  XDBC_TINYINT -6
  XDBC_BIT -7
  XDBC_WCHAR -8
  XDBC_WVARCHAR -9
}

/**
 * Detailed subtype information for XDBC_TYPE_DATETIME and XDBC_TYPE_INTERVAL.
 */
enum "XdbcDatetimeSubcode" {
  option allow_alias=true
  XDBC_SUBCODE_UNKNOWN 0
  XDBC_SUBCODE_YEAR 1
  XDBC_SUBCODE_DATE 1
  XDBC_SUBCODE_TIME 2
  XDBC_SUBCODE_MONTH 2
  XDBC_SUBCODE_TIMESTAMP 3
  XDBC_SUBCODE_DAY 3
  XDBC_SUBCODE_TIME_WITH_TIMEZONE 4
  XDBC_SUBCODE_HOUR 4
  XDBC_SUBCODE_TIMESTAMP_WITH_TIMEZONE 5
  XDBC_SUBCODE_MINUTE 5
  XDBC_SUBCODE_SECOND 6
  XDBC_SUBCODE_YEAR_TO_MONTH 7
  XDBC_SUBCODE_DAY_TO_HOUR 8
  XDBC_SUBCODE_DAY_TO_MINUTE 9
  XDBC_SUBCODE_DAY_TO_SECOND 10
  XDBC_SUBCODE_HOUR_TO_MINUTE 11
  XDBC_SUBCODE_HOUR_TO_SECOND 12
  XDBC_SUBCODE_MINUTE_TO_SECOND 13
  XDBC_SUBCODE_INTERVAL_YEAR 101
  XDBC_SUBCODE_INTERVAL_MONTH 102
  XDBC_SUBCODE_INTERVAL_DAY 103
  XDBC_SUBCODE_INTERVAL_HOUR 104
  XDBC_SUBCODE_INTERVAL_MINUTE 105
  XDBC_SUBCODE_INTERVAL_SECOND 106
  XDBC_SUBCODE_INTERVAL_YEAR_TO_MONTH 107
  XDBC_SUBCODE_INTERVAL_DAY_TO_HOUR 108
  XDBC_SUBCODE_INTERVAL_DAY_TO_MINUTE 109
  XDBC_SUBCODE_INTERVAL_DAY_TO_SECOND 110
  XDBC_SUBCODE_INTERVAL_HOUR_TO_MINUTE 111
  XDBC_SUBCODE_INTERVAL_HOUR_TO_SECOND 112
  XDBC_SUBCODE_INTERVAL_MINUTE_TO_SECOND 113
}

enum "Nullable" {
  /**
   * Indicates that the fields does not allow the use of null values.
   */
  NULLABILITY_NO_NULLS 0

  /**
   * Indicates that the fields allow the use of null values.
   */
  NULLABILITY_NULLABLE 1

  /**
   * Indicates that nullability of the fields cannot be determined.
   */
  NULLABILITY_UNKNOWN 2
}

enum "Searchable" {
  /**
   * Indicates that column cannot be used in a WHERE clause.
   */
  SEARCHABLE_NONE 0

  /**
   * Indicates that the column can be used in a WHERE clause if it is using a
   * LIKE operator.
   */
  SEARCHABLE_CHAR 1

  /**
   * Indicates that the column can be used In a WHERE clause with any
   * operator other than LIKE.
   *
   * - Allowed operators: comparison, quantified comparison, BETWEEN,
   *                      DISTINCT, IN, MATCH, and UNIQUE.
   */
  SEARCHABLE_BASIC 2

  /**
   * Indicates that the column can be used in a WHERE clause using any operator.
   */
  SEARCHABLE_FULL 3
}

message "CommandGetXdbcTypeInfo" {
  /*
   * Specifies the data type to search for the info.
   */
  field optional=true "data_type" "int32" 1
}

// The returned data should be ordered by data_type and then by type_name.
schema "XdbcTypeInfoSchema" {
  field "type_name" "utf8" not_null=true
  comment r#"The name of the data type, for example: VARCHAR, INTEGER, etc."#
  field "data_type" "int32" not_null=true
  comment "The SQL data type."
  field "precision" "int32"
  comment "The maximum size supported by that column.
In case of exact numeric types, this represents the maximum precision.
In case of string types, this represents the character length.
In case of datetime data types, this represents the length in characters of the string representation.
NULL is returned for data types where column size is not applicable."
  field "literal_prefix" "utf8"
  comment "Character or characters used to prefix a literal, NULL is returned for data types
where a literal prefix is not applicable."
  field "literal_suffix" "utf8"
  comment "Character or characters used to terminate a literal, NULL is returned for data types
where a literal suffix is not applicable."
  field "create_params" "list" {
    item "utf8" not_null=true 
  }
  comment "A list of keywords corresponding to which parameters can be used when creating
a column for that specific type.
NULL is returned if there are no parameters for the data type definition."
  field "nullable" "int32" not_null=true
  comment "Shows if the data type accepts a NULL value. The possible values can be seen in the
Nullable enum."
  field "case_sensitive" "bool" not_null=true
  comment "Shows if a character data type is case-sensitive in collations and comparisons."
  field "searchable" "int32" not_null=true
  comment "Shows how the data type is used in a WHERE clause.
The possible values can be seen in the Searchable enum."
  field "unsigned_attribute" "bool"
  comment "Shows if the data type is unsigned. NULL is returned if the attribute is
not applicable to the data type or the data type is not numeric."
  field "fixed_prec_scale" "bool" not_null=true
  comment "Shows if the data type has predefined fixed precision and scale."
  field "auto_increment" "bool"
  comment "Shows if the data type is auto incremental. NULL is returned if the attribute
is not applicable to the data type or the data type is not numeric."
  field "local_type_name" "utf8"
  comment "Localized version of the data source-dependent name of the data type. NULL
is returned if a localized name is not supported by the data source."
  field "minimum_scale" "int32"
  comment "The minimum scale of the data type on the data source.
If a data type has a fixed scale, the MINIMUM_SCALE and MAXIMUM_SCALE
columns both contain this value. NULL is returned if scale is not applicable."
  field "maximum_scale" "int32"
  comment "The maximum scale of the data type on the data source.
NULL is returned if scale is not applicable."
  field "sql_data_type" "int32" not_null=true
  comment "The value of the SQL DATA TYPE which has the same values
as data_type value. Except for interval and datetime, which uses generic values.
More info about those types can be obtained through datetime_subcode. The
possible values can be seen in the XdbcDataType enum."
  field "datetime_subcode" "int32"
  comment "Only used when the SQL DATA TYPE is interval or datetime. It contains
its sub types. For type different from interval and datetime, this value
is NULL. The possible values can be seen in the XdbcDatetimeSubcode enum."
  field "num_prec_radix" "int32"
  comment "If the data type is an approximate numeric type, this column contains
the value 2 to indicate that COLUMN_SIZE specifies a number of bits. For
exact numeric types, this column contains the value 10 to indicate that
column size specifies a number of decimal digits. Otherwise, this column is NULL."
  field "interval_precision" "int32"
  comment "If the data type is an interval data type, then this column contains the value
of the interval leading precision. Otherwise, this column is NULL. This fields
is only relevant to be used by ODBC."
}

message "CommandGetDbSchemas" {
  /*
   * Specifies the Catalog to search for the tables.
   * An empty string retrieves those without a catalog.
   * If omitted the catalog name should not be used to narrow the search.
   */
  field optional=true "catalog" "string" 1

  /*
   * Specifies a filter pattern for schemas to search for.
   * When no db_schema_filter_pattern is provided, the pattern will not be used to narrow the search.
   * In the pattern string, two special characters can be used to denote matching rules:
   *    - "%" means to match any substring with 0 or more characters.
   *    - "_" means to match any one character.
   */
  field optional=true "db_schema_filter_pattern" "string" 2
}

    // The returned data should be ordered by catalog_name, then by schema_name.
    output format="arrow" {
      field "catalog_name" "utf8"
      field "schema_name" "utf8" not_null=true
    }

message "CommandGetCatalogs"

// The returned data should be ordered by catalog_name.
schema "CatalogsSchema" {
    field "catalog_name" "utf8" not_null=true
}

message "CommandGetTables" {
  /*
   * Specifies the Catalog to search for the tables.
   * An empty string retrieves those without a catalog.
   * If omitted the catalog name should not be used to narrow the search.
   */
  field optional=true "catalog" "string" 1

  /*
   * Specifies a filter pattern for schemas to search for.
   * When no db_schema_filter_pattern is provided, all schemas matching other filters are searched.
   * In the pattern string, two special characters can be used to denote matching rules:
   *    - "%" means to match any substring with 0 or more characters.
   *    - "_" means to match any one character.
   */
  field optional=true "db_schema_filter_pattern" "string" 2

  /*
   * Specifies a filter pattern for tables to search for.
   * When no table_name_filter_pattern is provided, all tables matching other filters are searched.
   * In the pattern string, two special characters can be used to denote matching rules:
   *    - "%" means to match any substring with 0 or more characters.
   *    - "_" means to match any one character.
   */
  field optional=true "table_name_filter_pattern" "string" 3

  /*
   * Specifies a filter of table types which must match.
   * The table types depend on vendor/implementation. It is usually used to separate tables from views or system tables.
   * TABLE, VIEW, and SYSTEM TABLE are commonly supported.
   */
  field repeated=true "table_types" "string" 4

  // Specifies if the Arrow schema should be returned for found tables.
  field "include_schema" "bool" 5
}

message "TablesSchema" {
  // The returned data should be ordered by catalog_name, db_schema_name,
  // table_name, then table_type, followed by table_schema if requested.
  field "catalog_name" "utf8"
  field "db_schema_name" "utf8"
  field "table_name" "utf8" not_null=true
  field "table_type" "utf8" not_null=true
  // XXX: this field is optional and if it's missing, validation should not fail.
  field "table_schema" "bytes" not_null=true
  comment r#"Fields on table_schema may contain the following metadata:
- ARROW:FLIGHT:SQL:CATALOG_NAME      - Table's catalog name
- ARROW:FLIGHT:SQL:DB_SCHEMA_NAME    - Database schema name
- ARROW:FLIGHT:SQL:TABLE_NAME        - Table name
- ARROW:FLIGHT:SQL:TYPE_NAME         - The data source-specific name for the data type of the column.
- ARROW:FLIGHT:SQL:PRECISION         - Column precision/size
- ARROW:FLIGHT:SQL:SCALE             - Column scale/decimal digits if applicable
- ARROW:FLIGHT:SQL:IS_AUTO_INCREMENT - "1" indicates if the column is auto incremented, "0" otherwise.
- ARROW:FLIGHT:SQL:IS_CASE_SENSITIVE - "1" indicates if the column is case-sensitive, "0" otherwise.
- ARROW:FLIGHT:SQL:IS_READ_ONLY      - "1" indicates if the column is read only, "0" otherwise.
- ARROW:FLIGHT:SQL:IS_SEARCHABLE     - "1" indicates if the column is searchable via WHERE clause, "0" otherwise."#
}

message "CommandGetTableTypes"

// The table types depend on vendor/implementation. It is usually used to
// separate tables from views or system tables. 'TABLE', 'VIEW', and
// 'SYSTEM TABLE' are commonly supported.
//
// The returned data should be ordered by table_type.
schema "TableTypesSchema" {
  field "table_type" "utf8" not_null=true
}

/*
 * Represents a request to retrieve the primary keys of a table.
 */
message "CommandGetPrimaryKeys" {
  /*
   * Specifies the catalog to search for the table.
   * An empty string retrieves those without a catalog.
   * If omitted the catalog name should not be used to narrow the search.
   */
  field optional=true "catalog" "string" 1

  /*
   * Specifies the schema to search for the table.
   * An empty string retrieves those without a schema.
   * If omitted the schema name should not be used to narrow the search.
   */
  field optional=true "db_schema" "string"  2

  // Specifies the table to get the primary keys for.
  field "table" "string" 3
}

// The returned data should be ordered by catalog_name, db_schema_name,
// table_name, key_name, then key_sequence.
schema "PrimaryKeysSchema" {
  field "catalog_name" "utf8"
  field "db_schema_name" "utf8"
  field "table_name" not_null=true "utf8"
  field "column_name" not_null=true "utf8" 
  field "key_name" "utf8"
  field "key_sequence" not_nul=true "int32"
}

enum "UpdateDeleteRules" {
  CASCADE 0
  RESTRICT 1
  SET_NULL 2
  NO_ACTION 3
  SET_DEFAULT 4
}

/*
 * Represents a request to retrieve a description of the foreign key columns that reference the given table's
 * primary key columns (the foreign keys exported by a table) of a table.
 */
message "CommandGetExportedKeys" {
  /*
   * Specifies the catalog to search for the foreign key table.
   * An empty string retrieves those without a catalog.
   * If omitted the catalog name should not be used to narrow the search.
   */
  field optional=true "catalog" "string" 1

  /*
   * Specifies the schema to search for the foreign key table.
   * An empty string retrieves those without a schema.
   * If omitted the schema name should not be used to narrow the search.
   */
  field optional=true "db_schema" "string" 2

  // Specifies the foreign key table to get the foreign keys for.
  field "table" "string" 3
}

// The returned data should be ordered by `fk_catalog_name`,
// `fk_db_schema_name`, `fk_table_name`, `fk_key_name`, then `key_sequence`.
// `update_rule` and `delete_rule` returns a byte that is equivalent to actions
// declared on `UpdateDeleteRules` enum.
schema "ExportedKeysSchema" {
  field "pk_catalog_name" "utf8"
  field "pk_db_schema_name" "utf8"
  field "pk_table_name" not_null=true "utf8"
  field "pk_column_name" not_null=true "utf8"
  field "fk_catalog_name" "utf8"
  field "fk_db_schema_name" "utf8"
  field "fk_table_name" not_null=true "utf8"
  field "fk_column_name" not_null=true "utf8"
  field "key_sequence" not_null=true "int32"
  field "fk_key_name" "utf8"
  field "pk_key_name" "utf8"
  field "update_rule" not_null=true "uint8"
  field "delete_rule" not_null=true "uint8"
}

/*
 * Represents a request to retrieve the foreign keys of a table.
 */
message "CommandGetImportedKeys" {
  /*
   * Specifies the catalog to search for the primary key table.
   * An empty string retrieves those without a catalog.
   * If omitted the catalog name should not be used to narrow the search.
   */
  field optional=true "catalog" "string" 1

  /*
   * Specifies the schema to search for the primary key table.
   * An empty string retrieves those without a schema.
   * If omitted the schema name should not be used to narrow the search.
   */
  field optional=true "db_schema" "string" 2

  // Specifies the primary key table to get the foreign keys for.
  field "table" "string" 3
}

// The returned data should be ordered by `pk_catalog_name`,
// `pk_db_schema_name`, `pk_table_name`, `pk_key_name`, then `key_sequence`.
// `update_rule` and `delete_rule` returns a byte that is equivalent to actions:
//    - 0 = CASCADE
//    - 1 = RESTRICT
//    - 2 = SET NULL
//    - 3 = NO ACTION
//    - 4 = SET DEFAULT
schema "ImportedKeysSchema" {
  field "pk_catalog_name" "utf8"
  field "pk_db_schema_name" "utf8"
  field "pk_table_name" not_null=true "utf8"
  field "pk_column_name" not_null=true "utf8"
  field "fk_catalog_name" "utf8"
  field "fk_db_schema_name" "utf8"
  field "fk_table_name" not_null=true "utf8"
  field "fk_column_name" not_null=true "utf8"
  field "key_sequence" not_null=true "int32"
  field "fk_key_name" "utf8"
  field "pk_key_name" "utf8"
  field "update_rule" not_null=true "uint8"
  field "delete_rule" not_null=true "uint8"
}

/*
 * Represents a request to retrieve a description of the foreign key columns in the given foreign key table that
 * reference the primary key or the columns representing a unique constraint of the parent table (could be the same
 * or a different table).
 */
message "CommandGetCrossReference" {
  /**
   * The catalog name where the parent table is.
   * An empty string retrieves those without a catalog.
   * If omitted the catalog name should not be used to narrow the search.
   */
  field optional=true "pk_catalog" "string" 1

  /**
   * The Schema name where the parent table is.
   * An empty string retrieves those without a schema.
   * If omitted the schema name should not be used to narrow the search.
   */
  field optional=true "pk_db_schema" "string" 2

  /**
   * The parent table name. It cannot be null.
   */
  field "string" "pk_table" 3

  /**
   * The catalog name where the foreign table is.
   * An empty string retrieves those without a catalog.
   * If omitted the catalog name should not be used to narrow the search.
   */
  field optional=true "fk_catalog" "string" 4

  /**
   * The schema name where the foreign table is.
   * An empty string retrieves those without a schema.
   * If omitted the schema name should not be used to narrow the search.
   */
  field optional=true "fk_db_schema" "string" 5

  /**
   * The foreign table name. It cannot be null.
   */
  field "fk_table" "string" 6
}

// The returned data should be ordered by `pk_catalog_name`,
// `pk_db_schema_name`, `pk_table_name`, `pk_key_name`, then `key_sequence`.
// `update_rule` and `delete_rule` returns a byte that is equivalent to actions:
//    - 0 = CASCADE
//    - 1 = RESTRICT
//    - 2 = SET NULL
//    - 3 = NO ACTION
//    - 4 = SET DEFAULT
schema "CrossReferenceSchema" {
  field "pk_catalog_name" "utf8"
  field "pk_db_schema_name" "utf8"
  field "pk_table_name" not_null=true "utf8"
  field "pk_column_name" not_null=true "utf8"
  field "fk_catalog_name" "utf8"
  field "fk_db_schema_name" "utf8"
  field "fk_table_name" not_null=true "utf8"
  field "fk_column_name" not_null=true "utf8"
  field "key_sequence" not_null=true "int32"
  field "fk_key_name" "utf8"
  field "pk_key_name" "utf8"
  field "update_rule" not_null=true "uint8"
  field "delete_rule" not_null=true "uint8"
}

// Query Execution Action Messages

// TODO: ...

service "FlightSql" {
  command "GetSqlInfo" {
    input "CommangGetSqlInfo"
    output "SqlInfoSchema"
  }

  command "GetXdbcTypeInfo" {
    input "CommandGetXdbcTypeInfo"
    output "XdbcTypeInfoSchema"
  }

  command "GetDbSchemas" {
    input "CommandGetDbSchemas"
    output "DbSchemasSchema"
  }

  command "GetCatalogs" {
    input "CommandGetCatalogs"
    output "CatalogsSchema"
  }

  command "GetTables" {
    input "CommandGetTables"
    output "TablesSchema"
  }

  command "GetTableTypes" {
    input "CommandGetTableTypes"
    output "TableTypesSchema"
  }

  command "GetPrimaryKeys" {
    input "CommandGetPrimaryKeys"
    output "PrimaryKeysSchema"
  }

  command "GetExportedKeys" {
    input "CommandGetExportedKeys"
    output "ExportedKeysSchema"
  }

  command "GetImportedKeys" {
    input "CommandGetImportedKeys"
    output "ImportedKeysSchema"
  }

  command "GetCrossReference" {
    input "CommandGetCrossReference"
    output "CrossReferenceSchema"
  }
}
